# Contents
1. [기계어에서 객체지향 언어로](#기계어에서-객체지향-언어로)
2. [자바와 절차적/구조적 프로그래밍](#자바와-절차적구조적-프로그래밍)
3. [자바와 객체 지향](#자바와-객체-지향)




## 기계어에서 객체지향 언어로
**기계어란 0과 1로만 이루어져 있어 컴퓨터만이 이해할 수 있는 언어이다.** 이 기계어의 단점은 일단 사람이 이해하기 힘든다는 점과 각 CPU 회사마다 다르다는 것이다. 즉,
코드의 이식성이 좋지 않기 때문에 기계어 프로그래밍을 하던 개발자들은 매우 힘들었을 것이다.

이를 해결하기 위해 등장한 언어가 바로 어셈블리어이다. 이는 기존의 0과 1의 나열에서 벗어나 좀 더 인간친화적인 언어 형태를 갖추었다. ADD, PLUS 등등이 대표적이다.
그러나 어셈블리어도 치명적인 단점이 있었는데, **바로 각 운영체제, 하드웨어 종류에 따라 고유의 어셈블리어가 존재했던 것이다.** 즉, A사의 어셈블리어와 B사의 어셈블리어는
서로 호환이 되지 않았다. 어셈블리어는 기계어보다는 인간이 다루기 쉬운 언어였으나 이식성의 문제는 해결하지 못했다.

이처럼 하나의 로직을 수행하기 위해 여러 언어로 작성해야 하는 번거로움은 C언어를 통해 해결되었다. 즉, C언어는 하나의 소스코드를 작성하면 각 기종(OS)에 맞는
컴파일러를 통해 기계어 목적 파일로 변환된다. **즉, 기종마다 소스코드를 작성하지 않고 하나의 소스코드를 통해 여러 기종에서 실행이 가능한 것이 C언어의 장점이다.**

가상머신, **JVM의 등장으로 인해 자바 언어에서는 여러 종류의 컴파일러를 갖출 필요가 사라졌다.** 하나의 소스코드를 하나의 컴파일러를 통해 목적 파일로 변환된다.
그리고 각 기종에 맞는 JVM에서 실행된다. 이 때 각 기종에 맞는 JRE를 통해 JVM이 동작하게 된다.

### 책에서 소개한 진정한 객체 지향 언어 - 자바
저자는 자바를 진정한 객체지향 언어로 소개한다. **자바는 객체, 즉 Class가 반드시 있어야 한다.** Class를 기반으로 동작하는 언어이기 때문에 클래스 외부에서 자바는 존재할 수 없다.
또한 모든 메서드들은 클래스를 통해서만 접근할 수 있다. ex) 클래스.메서드명(), 객체.메서드명() 심지어 main 함수 또한 하나의 클래스 안에서만 존재할 수 있다.  
**반면에 C++의 main 함수는 클래스와 별개로 존재할 수 있다.**

## 자바와 절차적/구조적 프로그래밍
자바를 이해하기 위해서는 먼저 JVM에 대해 알아야 한다. JVM은 말 그대로 가상기계이다. 컴퓨터를 통해 어떠한 기능을 수행하기 위해서는 하드웨어, 소프트웨어, 그리고 운영체제 이 세 가지 요소가
기본적으로 필요하다. 자바가 실행되기 위해서도 마찬가지로 이 세 가지 요소가 필요한데, JVM은 이 중 하드웨어에 속한다. 그리고 이 JVM 내에서 돌아가는 소프트웨어가 JDK이며, 이를 가능하게 하는
운영체제 역할을 하는 것이 JRE이다. JDK 내에는 JRE와 JVM이 포함되어 있다. JDK는 자바 컴파일러인 javac.exe를 포함하고 있으며, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.

우리는 JDK 설치를 통해 자바를 실행할 수 있다. 이것이 가능한 이유는 JDK 내에 있는 컴파일러가 동작하며, JRE가 JVM에서 해당 목적 파일을 실행시키기 때문이다. 스프링 개발에 비유하자면,
우리는 각자의 로컬 컴퓨터에서 각 OS에 맞는 JVM을 사용해 소스코드를 개발한다. 그리고 이것이 배포가 되면 다른 로컬 컴퓨터에서 다른 OS일지라도 각기 다른 JVM 및 JRE를 통해 같은 소스코드를
실행할 수 있는 것이다.

### 자바를 이해하기 위한 메모리 구조
자바 프로그램이 메모리를 사용할 때는 코드 영역과 데이터 저장 영역으로 나눈다. 이 때 **데이터 저장 영역은 크게 스태틱 영역, 스택 영역, 힙 영역으로 나뉜다.**
자바의 main 메서드가 실행되기 위해서는 먼저 JRE가 main 메서드를 확인한다. 그리고 프로그램을 실행하기 위한 사전 준비에 들어간다. 먼저, JVM을 부팅하고 컴파일러를 통해 받은 목적 파일을 실행한다.
이 때, 모든 자바 프로그램이 반드시 포함하게 되는 패키지인 `java.lang`을 스태틱 영역에 로딩한다. 그리고 개발자가 작성한 모든 클래스와 import 패키지도 스태틱 영역에 로딩한다.  
**즉, 스태틱 영역은
클래스들의 놀이터이다.** 이제 모든 전처리 과정이 끝났고, 본격적으로 main 메서드가 실행되면, 이제는 스태틱 영역이 아닌 스택 영역에 main 메서드의 스택 프레임이 할당된다. **즉, 스택 영역은
메서드들의 놀이터이다.** 메서드 단위별로 스택 영역에 프레임 단위로 할당된다. 블럭의 시작(`{`)과 끝(`}`)으로 구분할 수 있다.

### 블록을 통해 구분되는 지역변수
우리는 main 메서드 내에서 다양한 블럭들을 생성하게 된다. 특히, 제어문(조건문, 반복문)의 경우 다양한 블럭 단위로 실행된다. 이 떄 블럭 내에서 생성하는 변수들은 해당 블럭이 종료되면 메모리에서 사라진다.
만약, main 메서드 내에서 if문이 실행된다면 스택 영역에 있는 main 스택 프레임이 생성되고, 그 안에 if문 스택 프레임이 생성되는 것이다. 그리고 if문의 블럭 끝인 `}`을 만나면 해당 if문에 있는 변수들은 소멸된다.

이처럼 **지역 변수는 스택 영역 내에 있는 스택 프레임 안에서만 생명 주기를 갖는다. 그에 반면에 스태틱 영역에 존재하는 클래스 멤버 변수들은 JVM이 종료될 때까지 메모리에 존재한다.**

**외부 블럭에서 내부 블록의 변수에는 접근할 수 없지만 그 역은 가능하다.** & **외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.**
이 말은 지역 변수를 접근할 수 있는 것이 외부에서는 불가능하다는 것이다. 우리는 스택 영역 내에 있는 스택 프레임에서의 지역변수에 대해 배웠기 때문에 이제 이 말의 뜻을 이해할 수 있다.

### 메서드가 실행될 때마다 다른 메서드 프레임이 생성된다.
```java
public class Start4 {
  public static void main(String[] args){
    int k = 5;
    int m;

    m = square(k);
  }

  private static int square(int k){
    int result;
    k = 25;
    result = k;
    return result;
  }
}
```
스택 영역 내에 main 메서드 프레임이 생성되고, square라는 메서드를 호출했을 때, 스택 영역 내에 또 다른 square 메서드 스택 프레임이 생성된다. 그리고 매개변수인 k와 result를 해당 프레임 내에 저장한다.
따라서 main 메서드 내에서 선언된 k와 square 메서드 내에서 생성된 k는 전혀 다른 것이다. main 메서드 내에서 전달한 k 값의 경우, 그저 값만 넘겨주는 것이므로, **이를 Call By Value라고 한다.
메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달하는 것이다.**

### 전역변수의 사용을 지양할 것
두 메서드 사이에 값을 전달하기 위해 메서드를 호출할 때 전역변수를 사용하여 값을 공유할 수 있다. 
```java
public class Start5 {
  static int share = 10;

  public static void main(String[] args){
    share = 55;
    int m;

    m = square(share);
  }

  private static int square(int k){
    share = k + 25;
    return share;
  }
}
```
이처럼 `share`라는 static 변수가 존재할 때, 메모리의 변화는 어떻게 될까? 먼저 스태틱 영역에 클래스에 관한 것들이 로딩된 후, `share`라는 변수도 스태틱 영역에 할당된다.
그리고 main 메서드 프레임과 square 메서드 프레임이 각각 스택 영역에 할당된다. main 메서드와 square 메서드는 서로 전역 변수인 `share`에 접근하고 있는데, 이로 인해 초기 값이 10이었던
`share` 변수가 최종적으로는 80으로 변경된다.

전역 변수는 코드 어느 곳에서나 접근이 가능하기 때문에 전역 변수라고 하며, 여러 메서드들이 공유해서 사용하기 때문에 공유 변수라고도 한다. 프로젝트의 규모에 따라 여러 메서드들이 전역 변수의
값을 변경하게 되면, 전역 변수의 값을 추적하기 어려워질 것이다. 위 예제에서도 전역변수 `share`가 두 번이나 변경이 되었는데 실제 프로젝트 규모에서 전역 변수를 건드리게 되면 값을 파악하기 매우 힘들 것이다.
**따라서 전역 변수를 사용하려면 단순히 읽기 전용으로 값을 공유하는 것을 추천한다. (static final)**

### 멀티 스레드/ 멀티 프로세스의 이해
**멀티 스레드란, 하나의 메모리 내에 스택 영역을 스레드 개수 만큼 분할해서 사용하는 것이다. 반면에 멀티 프로세스란, 여러 개의 메모리를 갖는 구조이다.**
따라서 멀티 프로세스는 각 프로세스마다 메모리가 있고, 각자의 고유 공간이기 때문에 서로 참조할 수 없다. 하지만 멀티 스레드는 하나의 메모리만 사용한다.

- 멀티 프로세스 : 서로의 영역을 침범할 수 없기 때문에 안전한 구조이지만, 메모리 사용량이 많다.
- 멀티 스레드 : 힙과 스태틱 영역은 공유하지만 서로의 스택 영역은 접근할 수 없다. 따라서 메모리 사용량이 적다.

스프링 MVC1을 배우면서 서블릿은 요청마다 스레드를 생성해서 처리한다라고 배웠다. **이처럼 요청마다 프로세스를 생성하는 것이 아닌 공유 자원을 활용해 다중 스레드를 지원하는 것이
보다 메모리를 효율적으로 사용하는 방법임을 알 수 있다.**

그렇다면 멀티 스레드 환경에서 전역 변수를 사용하는 것이 왜 문제가 될까? 스레드1에서 전역변수 A에 10을 할당하고, 스레드2에서 전역변수 A에 다시 20으로 할당한 뒤 스레드1에서 전역변수 A를 출력한다면
스레드1이 할당한 10이 아닌 20이 출력된다. 이처럼 멀티 스레드 환경에서 전역변수를 사용하면 스레드 안정성이 깨질 수 있다.

## 자바와 객체 지향
### 객체 지향은 인간 지향이다
프로그래밍 언어의 발전사를 보면 개발자를 더욱 편하고 이롭게 하기 위한 과정임을 알 수 있다. 기계어에서 어셈블리어 그리고 C/C++, 자바까지 모두 로우 레벨의 기계가 아닌 하이 레벨의 인간을 배려하기 위한
과정이다. 하지만 절차적/구조적 프로그래밍에서 사용한 포인터 개념은 기계 수준으로 낮춰야 이해할 수 있는 부분이다.  

**자바에서는 이러한 기계 종속적인 프로그래밍이 아닌 인간 중심에서
우리 눈으로 보고 직관적으로 이해할 수 있는 사물이라는 개념을 통해 마치 현실세계와 동일한 수준으로 프로그래밍하는 방법을 선택했다.** 그것이 바로 객체 지향 프로그래밍인 것이다.
기존의 0과 1로 대볃뇌는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실세계를 인지하는 방식으로 프로그램을 만든 것이다. 따라서 객체 지향은 직관적이다.

### 클래스와 객체의 관계 : 붕어빵틀 과 붕어빵??
클래스와 객체의 관계를 이해할 때 붕어빵틀과 붕어빵이라는 개념을 많이 사용한다. 우리는 객체를 생성할 때, `클래스 객체명 = new 클래스();` 로 코드를 작성한다.
그렇다면 `붕어빵틀 붕어빵 = new 붕어빵틀();`이라는 코드가 과연 맞는 말인지 우리는 의심할 수 있다. 논리에 맞지 않는 것이다. 붕어빵틀은 붕어빵 모양을 만들도록 하는
모형틀인 것이지 붕어빵의 개념이 아니다. 붕어빵에 들어가는 반죽과 팥 혹은 슈크림을 표현할 수 없는 것이다.

**즉, 클래스는 분류에 대한 개념이지 실체가 아니다. 하지만 객체는 실체다.** 클래스는 사람이고, 객체는 손흥민이다. 클래스는 펭귄이고, 객체는 뽀로로이다. 클래스와 객체를 구분하는 방법 중 하나는
나이를 물어보는 것이다.
- 사람의 나이는 몇 살인가? VS 손흥민의 나이는 몇 살인가?
- 펭귄의 나이는 몇 살인가? VS 뽀로로의 나이는 몇 살인가?

자바의 정석에서는 클래스를 일종의 설계도라고 표현하고 있다. 설계도는 해당 객체에 관한 정보들을 담고 있는 추상화된 개념이기에 붕어빵틀보다는 옳은 예시라고 생각한다. 어쨌든 클래스를 실체가 아닌 개념으로써 받아들여야
자바 프로그래밍에서 혼동하지 않게 된다. **우리가 실제로 자바에서 실행하는 많은 기능들은 클래스를 기반으로 생성된 객체 덕분이지 클래스 그 자체만으로 존재할 수는 없는 것이다.** (물론, 객체를 생성하지 않고 변수나 메서드를 사용하는
방법도 존재하긴 한다. - static)

### 추상화: 모델링
**객체 지향의 추상화는 곧 모델링이다.** 추상화란 구체적인 것을 분해해서 관심있는 특성만 가지고 재조합하는 것이다. 우리는 구현하고자 하는 것을 하나의 클래스로 모델링, 추상화하게 되는데 여기서 클래스는 특정 객체를 통칭할 수 있는
집합적 개념(분류)이다. 그리고 클래스를 통해 생성된 객체에 대해 **인스턴스**라는 표현을 더 자주 사용한다. 우리가 클래스를 설계할 때는 UML 다이어그램을 보통 사용한다. 여기에는 해당 클래스가 갖는 여러 속성들이 정의된다.

만약, 사람이라는 클래스를 설계한다면 키, 몸무게, 혈액형, 나이, 그리고 각종의 행위들을 정의할 수 있다. 이처럼 사람을 정의할 수 있는 건 수백, 수천가지가 존재한다. 하지만 어플리케이션 개발자에게 있어서 사람이라는 클래스에 필요한
속성들은 유한할 것이다. 이 때 사용되는 개념이 **컨텍스트(경계)**이다. 내가 설계한 클래스가 어디에 사용될 지를 명확하게 구분하는 것이다. 만약 병원 어플리케이션을 만들고 있다면 사람이라는 클래스는 환자로 구체화 될 것이며,
은행 어플리케이션을 만든다면 고객으로 구체화될 것이다. 이처럼 추상화(모델링) 과정에서도 구체화되는 부분이 분명 존재한다. **즉, 추상화란 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합한 것**이라 할 수 있다.

**추상화란 구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것 = 모델링**

모델링한 클래스가 실제 코드로 동작할 때 메모리에서는 어떤 일이 벌어질까? 일단 클래스들의 놀이터인 스태틱 영역에 해당하는 클래스가 다 로딩된다. 만약, 이 때 인스턴스 멤버가 있을 경우 해당 변수들은 스태틱 영역에 저장공간을 갖지 않는다.
이들은 객체가 생성되어야 존재하는 영역이기 때문에 스태틱이 아닌 힙 영역에서 동적으로 생성되기 때문이다. 객체 생성에 따른 메모리의 변화는 해당 책을 참고하는 것이 더 낫다고 생각해서 중요한 포인트만 적도록 하겠다.

먼저, `Mouse mickey = new Mouse();`라는 코드가 있을 때, 여기서 Mouse라는 클래스는 이미 스태틱 영역에 로딩되어 있다. 그리고, new 생성자를 통해 실제 인스턴스를 생성하였고 이는 힙 영역에 저장된다. 그리고 저장된 메모리 주소를
`mickey`라는 참조 변수에 대입하였다. 이제부터는 `mickey`라는 변수를 통해 해당 객체에 접근할 수 있다. 이 후에 `mickey = null`로 하면 해당 참조변수는 생성된 객체를 참조하지 않는다. 그러면 가비지 컬렉터가 해당 인스턴스를 힙 영역에서
제거한다. 

#### static을 사용하는 법 : 클래스 멤버 변수
우리가 사람이라는 클래스를 설계한다면, 해당 클래스로 생성된 객체들이 갖는 공통적인 특성이 분명 존재한다. 바로 눈의 개수, 귀의 개수, 팔다리의 개수 등등 인간으로서 갖는 공통적인 성질이 존재한다. 힙 영역에 생성된 여러 사람 인스턴스들이
똑같은 값들을 담는 변수를 여러 공간 생성해 놓는다면 이는 매우 비효율적이다. 즉, 객체마다 공통으로 갖는 특성을 클래스 멤버로 분류하는 것인데 이 때 `static`을 사용한다. 그러면 해당 객체를 생성하지 않고도 클래스 멤버에 접근할 수 있다.
main 메서드가 `public static`인 이유도 여기에 있다. JVM 구동 시 스태틱 영역에 바로 배치되는 것이 클래스 및 static 변수/메서드인데, main 메서드는 특정 객체 생성과 관계없이 실행될 수 있어야 하기 때문이다.

따라서 클래스 멤버 변수의 경우, 스태틱 영역에서 클래스가 로딩될 때 저장공간도 같이 생긴다. 반면에 인스턴스 멤버의 경우는 생성되지 않는다. 지역변수는 사용자가 초기화 하지 않으면 쓰레기 값을 갖는다고 하였다. 하지만 클래스 변수 및 인스턴스 변수는 여러 메서드 혹은 객체가 공유하는 변수들이다. 따라서 이들을 누가 초기화할지 정하지 않고 자동으로 초기화하도록 설정되어 있다. 

- static 변수 : (= 클래스 [멤버] 속성, 정적 변수, 정적 속성), 스태틱 영역에 존재
- 인스턴스 변수 : (= 객체 [멤버] 속성, 객체 변수), 힙 영역에 존재
- local 변수 : (= 지역 변수), 스택 영역(스택 프레임 내부)에 존재

### 상속: 재사용 + 확장
상속이라고 하는 개념은 상속받는다는 말로 이해하면 혼동하기 쉽다. 객체 지향의 상속은 상속이 아닌 **재사용과 확장**으로 이해해야 한다. 실제로 자바에서 상속의 키워드는 `extends`이다.
상위 클래스가 동물이고, 하위 클래스가 포유류일 때, 동물이 포유류의 부모 개념이 아닌 것이다. 포유류는 동물을 좀 더 세분화하고 구체화한 개념(클래스)인 것이다. 동물이 가지고 있는 특성과 함께
포유류로써 갖는 특성을 추가하여 **확장(extends)**하는 것이다. 즉, 기존의 코드를 재사용하면서 확장하는 것이 상속의 주된 기능인 것이다.

**상위 클래스로 갈수록 추상화, 일반화됐다고 하며, 하위 클래스로 갈수록 구체화, 특수화 됐다고 말한다.** 상속관계에서 반드시 만족하는 문장이 있는데, 바로 **하위 클래스는 상위 클래스다.**
클래스 계층도가 동물<-포유류<-고래 일때, 포유류는 동물이다, 고래는 포유류다, 고래는 동물이다. 모두 말이 된다.

#### 객체 이름 명명 시 주의사항
클래스 이름은 클래스 답게, 객체 이름은 객체 답게 이름을 지어야 한다. 만약 Bird라는 클래스가 있다면 이를 바탕으로 생성되는 객체 명은 aBird, theBird 등이어야 한다.

상속의 큰 장점 중 하나는 기존의 코드를 반복해서 사용하지 않아도 된다는 것이다. 공통되는 부분은 상위 클래스로부터 가져올 수 있으며, 해당 변수/메서드 등이 해당된다. 또한 **하위 클래스는 상위 클래스다**를 만족하기 때문에
상위 클래스 타입의 참조변수로 하위 클래스 인스턴스를 참조할 수 있다. (ex. `동물 animal = new 포유류();`,`동물 whale = new 고래();`)

#### 상속은 is a 관계가 아닌 is a kind of 관계
- 김연아 is a 사람 -> 김연아는 한 명의 사람이다.
- 뽀로로 is a 펭귄 -> 뽀로로는 한 마리 펭귄이다.  
이처럼 상속의 관계를 단순히 `is a`로 표현하는 것은 와닿지 않고 무언가 어색하다. 하지만 이를 `is a kind of`로 바꾸면 어떻게 될까?
- 김연아 is a kind of 사람 -> 김연아는 사람 중 한 명이다.
- 뽀로로 is a kind of 펭귄 -> 뽀로로는 펭귄의 한 분류이다.

정리하자면 객체 지향의 상속은 다음 세 가지로 정의할 수 있다.
1. 객체 지향의 상속은 상위 클래스의 특성을 **재사용**하는 것이다.
2. 객체 지향의 상속은 상위 클래스의 특성을 **확장**하는 것이다.
3. 객체 지향의 상속은 **is a kind of** 관계를 만족해야 한다.

#### 다중상속 대신 선택한 방법 : 인터페이스
인터페이스는 보통 **~할 수 있는, be able to**의 의미를 갖고 있다. 실제로 자바 인터페이스 중에서는 `able`이 붙은 인터페이스가 많다. (ex. Comparable, Runnable)
상속과는 다르게 특정 클래스들이 공통적으로 갖는 부분을 인터페이스로 묶어주면, 유지 보수에 용이하며 확장성 있는 코드를 만들 수 있다.

#### 상속과 메모리
만약, 동물이라는 클래스와 포유류라는 클래스가 있고, 포유류의 상위 클래스가 동물 클래스라고 하자. 이 때, 포유류 객체를 생성한다면 힙 영역에는 동물 클래스와 포유류 클래스가 같이 생성된다.
즉, 상위 클래스 인스턴스와 하위 클래스 인스턴스가 같이 생기는 것이다. 물론 최상위 클래스인 Object 클래스의 인스턴스도 함께 생성된다.

### 다형성: 사용편의성
보통 다형성이라고 하면 상위 클래스와 하위 클래스에 관한 걸 얘기하지만, 이 책에서는 오버로딩과 오버라이딩을 객체 지향의 다형성이라 이야기하고 있다.
- 오버라이딩 : 상위 클래스의 메서드를 같은 이름과 인자로 구현부를 바꾸는 것
- 오버로딩 : 같은 이름과 다른 인자로 메서드를 여러 개 구현하는 것  
둘의 기능은 다르지만 어쨌든 개발자의 편의성을 고려해 생긴 기능이라는 것이다. 우리는 하위 클래스의 인스턴스 타입이 상위 클래스 인스턴스 타입으로 형변환 하는 경우, 형변환이 생략가능함을 알고 있다.
그 이유는 하위 클래스 인스턴스가 갖고 있는 멤버가 더 많기 때문에 상위 클래스 타입으로 형변환하는 것이 보다 안전하기 때문이다.

```java
public class Parent {
    public void show() {
        System.out.println("I'm a Parent");
    }
}

public class Child extends Parent {
    @Override
    public void show() {
        System.out.println("I'm a Child ");
    }
}

public static void main(String[] args) {
        Parent parent = new Parent();
        Child child = new Child();

        parent.show();
        child.show();

        System.out.println();

        Parent child2 = new Child();
        child2.show();

        Parent parent3 = new Parent();
        parent3.show();

    }
```
만약, `Parent child2 = new Child();`처럼 부모 타입 참조변수로 자식 인스턴스를 참조하더라도 실제로 호출되는 메서드는 자식(하위) 클래스의 메서드가 호출된다. 이 점을 기억해야 한다.
오버라이딩의 경우, **아무리 부모 타입의 참조변수를 사용했다고 하더라도 실제 인스턴스 타입의 메서드가 호출된다.** 물론 상위 클래스 타입의 참조변수를 사용하면, 하위 클래스의 멤버를 호출할 수는 없다.
하지만 **오버라이딩의 경우엔 상위 클래스든 하위 클래스든 어쨌든 메서드가 반드시 존재한다. (상위 클래스의 메서드를 하위 클래스가 재정의하는 것이기 때문에 둘 다 같은 메서드가 있을 수 밖에 없다.)**
따라서 오버라이딩의 경우에는 실제 인스턴스 타입의 메서드가 호출되는 것이다. (오버라이딩에 의해 상위 클래스의 메서드가 가려졌다고 이해하기)

그렇다면 이 점을 활용하여 우리는 상위 클래스 타입으로 참조변수를 사용하여, 여러 하위 클래스 타입의 메서드들을 호출할 수 있을 것이다.
```java
class Driver {
  public static void main(String[] args){
    동물[] 동물들 = new 동물[5];

    동물들[0] = new 쥐();
    동물들[1] = new 고양이();
    동물들[2] = new 강아지();
    동물들[3] = new 송아지();

    for(int i = 0; i < 동물들.length; i++){
      동물들[i].울어보세요();
    }
  }
}
```
이처럼 `쥐, 고양이, 강아지, 송아지` 클래스가 동물 클래스의 하위 클래스라면, **우리는 오버라이딩된 `울어보세요()`라는 메서드를 상위 클래스 타입인 `동물` 타입 단 하나로 호출이 가능하다.**
이것이 바로 객체지향의 다형성이 사용자에게 편의성을 제공하는 부분이다. 특히, 클래스를 설계할 때 상속을 사용해야 하는 이유에 대해 고민할 때 이와 같은 내용을 떠올려보고 적용해보도록 하자.
