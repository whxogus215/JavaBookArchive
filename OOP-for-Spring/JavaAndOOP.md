# Contents
1. [기계어에서 객체지향 언어로](#기계어에서-객체지향-언어로)
2. [자바와 절차적/구조적 프로그래밍](#자바와-절차적/구조적-프로그래밍)



## 기계어에서 객체지향 언어로
**기계어란 0과 1로만 이루어져 있어 컴퓨터만이 이해할 수 있는 언어이다.** 이 기계어의 단점은 일단 사람이 이해하기 힘든다는 점과 각 CPU 회사마다 다르다는 것이다. 즉,
코드의 이식성이 좋지 않기 때문에 기계어 프로그래밍을 하던 개발자들은 매우 힘들었을 것이다.

이를 해결하기 위해 등장한 언어가 바로 어셈블리어이다. 이는 기존의 0과 1의 나열에서 벗어나 좀 더 인간친화적인 언어 형태를 갖추었다. ADD, PLUS 등등이 대표적이다.
그러나 어셈블리어도 치명적인 단점이 있었는데, **바로 각 운영체제, 하드웨어 종류에 따라 고유의 어셈블리어가 존재했던 것이다.** 즉, A사의 어셈블리어와 B사의 어셈블리어는
서로 호환이 되지 않았다. 어셈블리어는 기계어보다는 인간이 다루기 쉬운 언어였으나 이식성의 문제는 해결하지 못했다.

이처럼 하나의 로직을 수행하기 위해 여러 언어로 작성해야 하는 번거로움은 C언어를 통해 해결되었다. 즉, C언어는 하나의 소스코드를 작성하면 각 기종(OS)에 맞는
컴파일러를 통해 기계어 목적 파일로 변환된다. **즉, 기종마다 소스코드를 작성하지 않고 하나의 소스코드를 통해 여러 기종에서 실행이 가능한 것이 C언어의 장점이다.**

가상머신, **JVM의 등장으로 인해 자바 언어에서는 여러 종류의 컴파일러를 갖출 필요가 사라졌다.** 하나의 소스코드를 하나의 컴파일러를 통해 목적 파일로 변환된다.
그리고 각 기종에 맞는 JVM에서 실행된다. 이 때 각 기종에 맞는 JRE를 통해 JVM이 동작하게 된다.

### 책에서 소개한 진정한 객체 지향 언어 - 자바
저자는 자바를 진정한 객체지향 언어로 소개한다. **자바는 객체, 즉 Class가 반드시 있어야 한다.** Class를 기반으로 동작하는 언어이기 때문에 클래스 외부에서 자바는 존재할 수 없다.
또한 모든 메서드들은 클래스를 통해서만 접근할 수 있다. ex) 클래스.메서드명(), 객체.메서드명() 심지어 main 함수 또한 하나의 클래스 안에서만 존재할 수 있다.  
**반면에 C++의 main 함수는 클래스와 별개로 존재할 수 있다.**

## 자바와 절차적/구조적 프로그래밍
자바를 이해하기 위해서는 먼저 JVM에 대해 알아야 한다. JVM은 말 그대로 가상기계이다. 컴퓨터를 통해 어떠한 기능을 수행하기 위해서는 하드웨어, 소프트웨어, 그리고 운영체제 이 세 가지 요소가
기본적으로 필요하다. 자바가 실행되기 위해서도 마찬가지로 이 세 가지 요소가 필요한데, JVM은 이 중 하드웨어에 속한다. 그리고 이 JVM 내에서 돌아가는 소프트웨어가 JDK이며, 이를 가능하게 하는
운영체제 역할을 하는 것이 JRE이다. JDK 내에는 JRE와 JVM이 포함되어 있다. JDK는 자바 컴파일러인 javac.exe를 포함하고 있으며, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.

우리는 JDK 설치를 통해 자바를 실행할 수 있다. 이것이 가능한 이유는 JDK 내에 있는 컴파일러가 동작하며, JRE가 JVM에서 해당 목적 파일을 실행시키기 때문이다. 스프링 개발에 비유하자면,
우리는 각자의 로컬 컴퓨터에서 각 OS에 맞는 JVM을 사용해 소스코드를 개발한다. 그리고 이것이 배포가 되면 다른 로컬 컴퓨터에서 다른 OS일지라도 각기 다른 JVM 및 JRE를 통해 같은 소스코드를
실행할 수 있는 것이다.

### 자바를 이해하기 위한 메모리 구조
자바 프로그램이 메모리를 사용할 때는 코드 영역과 데이터 저장 영역으로 나눈다. 이 때 **데이터 저장 영역은 크게 스태틱 영역, 스택 영역, 힙 영역으로 나뉜다.**
자바의 main 메서드가 실행되기 위해서는 먼저 JRE가 main 메서드를 확인한다. 그리고 프로그램을 실행하기 위한 사전 준비에 들어간다. 먼저, JVM을 부팅하고 컴파일러를 통해 받은 목적 파일을 실행한다.
이 때, 모든 자바 프로그램이 반드시 포함하게 되는 패키지인 `java.lang`을 스태틱 영역에 로딩한다. 그리고 개발자가 작성한 모든 클래스와 import 패키지도 스태틱 영역에 로딩한다.  
**즉, 스태틱 영역은
클래스들의 놀이터이다.** 이제 모든 전처리 과정이 끝났고, 본격적으로 main 메서드가 실행되면, 이제는 스태틱 영역이 아닌 스택 영역에 main 메서드의 스택 프레임이 할당된다. **즉, 스택 영역은
메서드들의 놀이터이다.** 메서드 단위별로 스택 영역에 프레임 단위로 할당된다. 블럭의 시작(`{`)과 끝(`}`)으로 구분할 수 있다.

### 블록을 통해 구분되는 지역변수
우리는 main 메서드 내에서 다양한 블럭들을 생성하게 된다. 특히, 제어문(조건문, 반복문)의 경우 다양한 블럭 단위로 실행된다. 이 떄 블럭 내에서 생성하는 변수들은 해당 블럭이 종료되면 메모리에서 사라진다.
만약, main 메서드 내에서 if문이 실행된다면 스택 영역에 있는 main 스택 프레임이 생성되고, 그 안에 if문 스택 프레임이 생성되는 것이다. 그리고 if문의 블럭 끝인 `}`을 만나면 해당 if문에 있는 변수들은 소멸된다.

이처럼 **지역 변수는 스택 영역 내에 있는 스택 프레임 안에서만 생명 주기를 갖는다. 그에 반면에 스태틱 영역에 존재하는 클래스 멤버 변수들은 JVM이 종료될 때까지 메모리에 존재한다.**

**외부 블럭에서 내부 블록의 변수에는 접근할 수 없지만 그 역은 가능하다.** & **외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.**
이 말은 지역 변수를 접근할 수 있는 것이 외부에서는 불가능하다는 것이다. 우리는 스택 영역 내에 있는 스택 프레임에서의 지역변수에 대해 배웠기 때문에 이제 이 말의 뜻을 이해할 수 있다.

### 메서드가 실행될 때마다 다른 메서드 프레임이 생성된다.
```java
public class Start4 {
  public static void main(String[] args){
    int k = 5;
    int m;

    m = square(k);
  }

  private static int square(int k){
    int result;
    k = 25;
    result = k;
    return result;
  }
}
```
스택 영역 내에 main 메서드 프레임이 생성되고, square라는 메서드를 호출했을 때, 스택 영역 내에 또 다른 square 메서드 스택 프레임이 생성된다. 그리고 매개변수인 k와 result를 해당 프레임 내에 저장한다.
따라서 main 메서드 내에서 선언된 k와 square 메서드 내에서 생성된 k는 전혀 다른 것이다. main 메서드 내에서 전달한 k 값의 경우, 그저 값만 넘겨주는 것이므로, **이를 Call By Value라고 한다.
메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달하는 것이다.**

