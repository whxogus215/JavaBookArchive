# Contents
1. [기계어에서 객체지향 언어로](#기계어에서-객체지향-언어로)
2. [자바와 절차적/구조적 프로그래밍](#자바와-절차적구조적-프로그래밍)
3. [자바와 객체 지향](#자바와-객체-지향)



## 기계어에서 객체지향 언어로
**기계어란 0과 1로만 이루어져 있어 컴퓨터만이 이해할 수 있는 언어이다.** 이 기계어의 단점은 일단 사람이 이해하기 힘든다는 점과 각 CPU 회사마다 다르다는 것이다. 즉,
코드의 이식성이 좋지 않기 때문에 기계어 프로그래밍을 하던 개발자들은 매우 힘들었을 것이다.

이를 해결하기 위해 등장한 언어가 바로 어셈블리어이다. 이는 기존의 0과 1의 나열에서 벗어나 좀 더 인간친화적인 언어 형태를 갖추었다. ADD, PLUS 등등이 대표적이다.
그러나 어셈블리어도 치명적인 단점이 있었는데, **바로 각 운영체제, 하드웨어 종류에 따라 고유의 어셈블리어가 존재했던 것이다.** 즉, A사의 어셈블리어와 B사의 어셈블리어는
서로 호환이 되지 않았다. 어셈블리어는 기계어보다는 인간이 다루기 쉬운 언어였으나 이식성의 문제는 해결하지 못했다.

이처럼 하나의 로직을 수행하기 위해 여러 언어로 작성해야 하는 번거로움은 C언어를 통해 해결되었다. 즉, C언어는 하나의 소스코드를 작성하면 각 기종(OS)에 맞는
컴파일러를 통해 기계어 목적 파일로 변환된다. **즉, 기종마다 소스코드를 작성하지 않고 하나의 소스코드를 통해 여러 기종에서 실행이 가능한 것이 C언어의 장점이다.**

가상머신, **JVM의 등장으로 인해 자바 언어에서는 여러 종류의 컴파일러를 갖출 필요가 사라졌다.** 하나의 소스코드를 하나의 컴파일러를 통해 목적 파일로 변환된다.
그리고 각 기종에 맞는 JVM에서 실행된다. 이 때 각 기종에 맞는 JRE를 통해 JVM이 동작하게 된다.

### 책에서 소개한 진정한 객체 지향 언어 - 자바
저자는 자바를 진정한 객체지향 언어로 소개한다. **자바는 객체, 즉 Class가 반드시 있어야 한다.** Class를 기반으로 동작하는 언어이기 때문에 클래스 외부에서 자바는 존재할 수 없다.
또한 모든 메서드들은 클래스를 통해서만 접근할 수 있다. ex) 클래스.메서드명(), 객체.메서드명() 심지어 main 함수 또한 하나의 클래스 안에서만 존재할 수 있다.  
**반면에 C++의 main 함수는 클래스와 별개로 존재할 수 있다.**

## 자바와 절차적/구조적 프로그래밍
자바를 이해하기 위해서는 먼저 JVM에 대해 알아야 한다. JVM은 말 그대로 가상기계이다. 컴퓨터를 통해 어떠한 기능을 수행하기 위해서는 하드웨어, 소프트웨어, 그리고 운영체제 이 세 가지 요소가
기본적으로 필요하다. 자바가 실행되기 위해서도 마찬가지로 이 세 가지 요소가 필요한데, JVM은 이 중 하드웨어에 속한다. 그리고 이 JVM 내에서 돌아가는 소프트웨어가 JDK이며, 이를 가능하게 하는
운영체제 역할을 하는 것이 JRE이다. JDK 내에는 JRE와 JVM이 포함되어 있다. JDK는 자바 컴파일러인 javac.exe를 포함하고 있으며, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.

우리는 JDK 설치를 통해 자바를 실행할 수 있다. 이것이 가능한 이유는 JDK 내에 있는 컴파일러가 동작하며, JRE가 JVM에서 해당 목적 파일을 실행시키기 때문이다. 스프링 개발에 비유하자면,
우리는 각자의 로컬 컴퓨터에서 각 OS에 맞는 JVM을 사용해 소스코드를 개발한다. 그리고 이것이 배포가 되면 다른 로컬 컴퓨터에서 다른 OS일지라도 각기 다른 JVM 및 JRE를 통해 같은 소스코드를
실행할 수 있는 것이다.

### 자바를 이해하기 위한 메모리 구조
자바 프로그램이 메모리를 사용할 때는 코드 영역과 데이터 저장 영역으로 나눈다. 이 때 **데이터 저장 영역은 크게 스태틱 영역, 스택 영역, 힙 영역으로 나뉜다.**
자바의 main 메서드가 실행되기 위해서는 먼저 JRE가 main 메서드를 확인한다. 그리고 프로그램을 실행하기 위한 사전 준비에 들어간다. 먼저, JVM을 부팅하고 컴파일러를 통해 받은 목적 파일을 실행한다.
이 때, 모든 자바 프로그램이 반드시 포함하게 되는 패키지인 `java.lang`을 스태틱 영역에 로딩한다. 그리고 개발자가 작성한 모든 클래스와 import 패키지도 스태틱 영역에 로딩한다.  
**즉, 스태틱 영역은
클래스들의 놀이터이다.** 이제 모든 전처리 과정이 끝났고, 본격적으로 main 메서드가 실행되면, 이제는 스태틱 영역이 아닌 스택 영역에 main 메서드의 스택 프레임이 할당된다. **즉, 스택 영역은
메서드들의 놀이터이다.** 메서드 단위별로 스택 영역에 프레임 단위로 할당된다. 블럭의 시작(`{`)과 끝(`}`)으로 구분할 수 있다.

### 블록을 통해 구분되는 지역변수
우리는 main 메서드 내에서 다양한 블럭들을 생성하게 된다. 특히, 제어문(조건문, 반복문)의 경우 다양한 블럭 단위로 실행된다. 이 떄 블럭 내에서 생성하는 변수들은 해당 블럭이 종료되면 메모리에서 사라진다.
만약, main 메서드 내에서 if문이 실행된다면 스택 영역에 있는 main 스택 프레임이 생성되고, 그 안에 if문 스택 프레임이 생성되는 것이다. 그리고 if문의 블럭 끝인 `}`을 만나면 해당 if문에 있는 변수들은 소멸된다.

이처럼 **지역 변수는 스택 영역 내에 있는 스택 프레임 안에서만 생명 주기를 갖는다. 그에 반면에 스태틱 영역에 존재하는 클래스 멤버 변수들은 JVM이 종료될 때까지 메모리에 존재한다.**

**외부 블럭에서 내부 블록의 변수에는 접근할 수 없지만 그 역은 가능하다.** & **외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.**
이 말은 지역 변수를 접근할 수 있는 것이 외부에서는 불가능하다는 것이다. 우리는 스택 영역 내에 있는 스택 프레임에서의 지역변수에 대해 배웠기 때문에 이제 이 말의 뜻을 이해할 수 있다.

### 메서드가 실행될 때마다 다른 메서드 프레임이 생성된다.
```java
public class Start4 {
  public static void main(String[] args){
    int k = 5;
    int m;

    m = square(k);
  }

  private static int square(int k){
    int result;
    k = 25;
    result = k;
    return result;
  }
}
```
스택 영역 내에 main 메서드 프레임이 생성되고, square라는 메서드를 호출했을 때, 스택 영역 내에 또 다른 square 메서드 스택 프레임이 생성된다. 그리고 매개변수인 k와 result를 해당 프레임 내에 저장한다.
따라서 main 메서드 내에서 선언된 k와 square 메서드 내에서 생성된 k는 전혀 다른 것이다. main 메서드 내에서 전달한 k 값의 경우, 그저 값만 넘겨주는 것이므로, **이를 Call By Value라고 한다.
메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달하는 것이다.**

### 전역변수의 사용을 지양할 것
두 메서드 사이에 값을 전달하기 위해 메서드를 호출할 때 전역변수를 사용하여 값을 공유할 수 있다. 
```java
public class Start5 {
  static int share = 10;

  public static void main(String[] args){
    share = 55;
    int m;

    m = square(share);
  }

  private static int square(int k){
    share = k + 25;
    return share;
  }
}
```
이처럼 `share`라는 static 변수가 존재할 때, 메모리의 변화는 어떻게 될까? 먼저 스태틱 영역에 클래스에 관한 것들이 로딩된 후, `share`라는 변수도 스태틱 영역에 할당된다.
그리고 main 메서드 프레임과 square 메서드 프레임이 각각 스택 영역에 할당된다. main 메서드와 square 메서드는 서로 전역 변수인 `share`에 접근하고 있는데, 이로 인해 초기 값이 10이었던
`share` 변수가 최종적으로는 80으로 변경된다.

전역 변수는 코드 어느 곳에서나 접근이 가능하기 때문에 전역 변수라고 하며, 여러 메서드들이 공유해서 사용하기 때문에 공유 변수라고도 한다. 프로젝트의 규모에 따라 여러 메서드들이 전역 변수의
값을 변경하게 되면, 전역 변수의 값을 추적하기 어려워질 것이다. 위 예제에서도 전역변수 `share`가 두 번이나 변경이 되었는데 실제 프로젝트 규모에서 전역 변수를 건드리게 되면 값을 파악하기 매우 힘들 것이다.
**따라서 전역 변수를 사용하려면 단순히 읽기 전용으로 값을 공유하는 것을 추천한다. (static final)**

### 멀티 스레드/ 멀티 프로세스의 이해
**멀티 스레드란, 하나의 메모리 내에 스택 영역을 스레드 개수 만큼 분할해서 사용하는 것이다. 반면에 멀티 프로세스란, 여러 개의 메모리를 갖는 구조이다.**
따라서 멀티 프로세스는 각 프로세스마다 메모리가 있고, 각자의 고유 공간이기 때문에 서로 참조할 수 없다. 하지만 멀티 스레드는 하나의 메모리만 사용한다.

- 멀티 프로세스 : 서로의 영역을 침범할 수 없기 때문에 안전한 구조이지만, 메모리 사용량이 많다.
- 멀티 스레드 : 힙과 스태틱 영역은 공유하지만 서로의 스택 영역은 접근할 수 없다. 따라서 메모리 사용량이 적다.

스프링 MVC1을 배우면서 서블릿은 요청마다 스레드를 생성해서 처리한다라고 배웠다. **이처럼 요청마다 프로세스를 생성하는 것이 아닌 공유 자원을 활용해 다중 스레드를 지원하는 것이
보다 메모리를 효율적으로 사용하는 방법임을 알 수 있다.**

그렇다면 멀티 스레드 환경에서 전역 변수를 사용하는 것이 왜 문제가 될까? 스레드1에서 전역변수 A에 10을 할당하고, 스레드2에서 전역변수 A에 다시 20으로 할당한 뒤 스레드1에서 전역변수 A를 출력한다면
스레드1이 할당한 10이 아닌 20이 출력된다. 이처럼 멀티 스레드 환경에서 전역변수를 사용하면 스레드 안정성이 깨질 수 있다.

## 자바와 객체 지향
### 객체 지향은 인간 지향이다
프로그래밍 언어의 발전사를 보면 개발자를 더욱 편하고 이롭게 하기 위한 과정임을 알 수 있다. 기계어에서 어셈블리어 그리고 C/C++, 자바까지 모두 로우 레벨의 기계가 아닌 하이 레벨의 인간을 배려하기 위한
과정이다. 하지만 절차적/구조적 프로그래밍에서 사용한 포인터 개념은 기계 수준으로 낮춰야 이해할 수 있는 부분이다.  

**자바에서는 이러한 기계 종속적인 프로그래밍이 아닌 인간 중심에서
우리 눈으로 보고 직관적으로 이해할 수 있는 사물이라는 개념을 통해 마치 현실세계와 동일한 수준으로 프로그래밍하는 방법을 선택했다.** 그것이 바로 객체 지향 프로그래밍인 것이다.
기존의 0과 1로 대볃뇌는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실세계를 인지하는 방식으로 프로그램을 만든 것이다. 따라서 객체 지향은 직관적이다.

### 클래스와 객체의 관계 : 붕어빵틀 과 붕어빵??
클래스와 객체의 관계를 이해할 때 붕어빵틀과 붕어빵이라는 개념을 많이 사용한다. 우리는 객체를 생성할 때, `클래스 객체명 = new 클래스();` 로 코드를 작성한다.
그렇다면 `붕어빵틀 붕어빵 = new 붕어빵틀();`이라는 코드가 과연 맞는 말인지 우리는 의심할 수 있다. 논리에 맞지 않는 것이다. 붕어빵틀은 붕어빵 모양을 만들도록 하는
모형틀인 것이지 붕어빵의 개념이 아니다. 붕어빵에 들어가는 반죽과 팥 혹은 슈크림을 표현할 수 없는 것이다.

**즉, 클래스는 분류에 대한 개념이지 실체가 아니다. 하지만 객체는 실체다.** 클래스는 사람이고, 객체는 손흥민이다. 클래스는 펭귄이고, 객체는 뽀로로이다. 클래스와 객체를 구분하는 방법 중 하나는
나이를 물어보는 것이다.
- 사람의 나이는 몇 살인가? VS 손흥민의 나이는 몇 살인가?
- 펭귄의 나이는 몇 살인가? VS 뽀로로의 나이는 몇 살인가?

자바의 정석에서는 클래스를 일종의 설계도라고 표현하고 있다. 설계도는 해당 객체에 관한 정보들을 담고 있는 추상화된 개념이기에 붕어빵틀보다는 옳은 예시라고 생각한다. 어쨌든 클래스를 실체가 아닌 개념으로써 받아들여야
자바 프로그래밍에서 혼동하지 않게 된다. **우리가 실제로 자바에서 실행하는 많은 기능들은 클래스를 기반으로 생성된 객체 덕분이지 클래스 그 자체만으로 존재할 수는 없는 것이다.** (물론, 객체를 생성하지 않고 변수나 메서드를 사용하는
방법도 존재하긴 한다. - static)
